## Запуск
Для сборки нужна установленная JDK 11

Unix:

`gradlew run --console=plain`

Windows:

`gradlew.bat run --console=plain`

## Архитектура

Main создает объект класса Cli и необходимые ему зависимости (реализации двух парсеров и CommandExecutor). 
CommandExecutor'у он также при создании передает Map (имя функции -> реализация). 

Cli (интерпертатор) выполняет следующие действия:
1. Считывает строчки из указанного потока
2. Первым парсером находит места для подстановки переменных
3. Выполняет подстановки
4. Строит AST c помощью второго парсера
5. Для каждой команды в AST вызывает CommandsExecutor, которому передает 
имя команды, аргументы, текущий environment, и выход предыдущей команды в пайплайне

Парсеры реализуют общий интерфейс CliParser.

CommandExecutor пытается найти имя команды в Map'е, переданной в конструктор, и в случае
успеха вызывает внутренную команду. Если команды из таким именем нет, 
то вызывает внешние команды через `scala.sys.process.Process`

Все внутренние команды реализуют общий интерфейс Command. 
Принимают и возвращают стримы, чтобы не считывать все файлы в память (это верно и для внешних команд)

## Grep

Были рассмотрены следующие библиотеки:
1. scallop (выбрана данная библиотека)
2. scopt
3. sopt

Рассматривать Java-библиотеки не было необходимости, так как данные scala-библиотеки реализуют весь необходимый функционал и при этом с ними будет удобнее работать (нет необходимости конвертировать коллекции и примитивные типы из Java в Scala).

#### scallop 
Простой и лаконичный синтексис объявления новых парсеров аргументов. 
Меньше возможностей для кастомизации в сравнении с scopt, но имеющегося функционала полностью хватает для решения задачи.
Подробная структурированная документация.

#### scopt
Самая популярная библиотека для парсинга аргументов командной строки на Scala.
Предоставляет возможность детальной настройки парсеров, но использовать ее при этом сложнее (и количество кода больше).
Документация менее подробная, нежели у scallop.

#### sopt
Библиотека не очень популярна и документации к ней мало.
Конфигурирование происходит с помощью аннотаций + использует рефлексию (сложнее отлаживать).


![Diagram](/cli/cli_diagram.png?raw=true)
